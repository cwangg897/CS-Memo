1. JVM 에서의 autoboxing 이란 어떤 현상을 말하는 걸까요?
<pre>
오토박싱(Autoboxing)은 Java 컴파일러가 원시 타입(Primitive types)과 해당 객체 래퍼 클래스 간에 수행하는 자동 변환을 말한다. 
예를 들어 int를 Integer로, double을 Double로 변환하는 식이다. 
래퍼클래스에서 -> 프리미티브와같은 변환이 다른 방향으로 진행되는 경우 이를 언박싱(unboxing)이라고 한다.
원시타입의 값을 적당한 래퍼 클래스의 타입으로 변경하는 것을 오토박싱이라고 한다.
래퍼 클래스에서 원시타입은 언박싱
</pre>


2. interface default implementation 이란? abstract class 를 상속받는 것과 기본 구현을 들고 있는 interface 를 implements 하는것은 어떤 차이가 있나요?
<pre>
java8부터 default 키워드를 사용해서 interface에 메소드를 선언할 수 있게 되어있습니다.
메소드를 default 키워드를 사용해 선언함으로써 메소드의 body, 즉 구현부를 작성할 수 있게 되었다. 

추상클래스는 클래스들간의 공통적인 메소드를 추출해서 추상클래스안에넣어둡니다.
공통적인 변수들도 똑같습니다.

인터페이스와 추상클래스의 차이는 인터페이스는 implements를 여러개 가능하지만 추상클래스는한번가능합니다.
추상클래스는 변수를 가지지만 인터페이스는 변수를 갖지못한다는점입니다.

추상클래스와 인터페이스 모두 객체를 생성할수 없습니다

자바의 일반 클래스는 부모 클래스를 단 하나만 가져야 하므로 여러 부모 클래스를 갖는 다중 상속을 지원하지 않는다. 
그러나 인터페이스는 추상 클래스보다 더 추상적이므로 여러 인터페이스를 상속받는 다중 상속을 지원한다. 
그리고 인터페이스는 클래스가 아니다. 그래서 인터페이스를 구현 하는 클래스는 implements 를 통해서 구현을 하고 인터페이스 끼리의 상속을 받을 때는 extends 를 사용한다.
</pre>

#### 추상클래스란?
<pre>
추상 클래스는 하나의 추상 메서드만 포함하면 추상클래스가 됩니다. 
추상메서드가 없어도 abstact클래스인데 사용하는 목적이 다형성을 위하고 반복적인것을 지우기위한것이라고생각한다
이 때 추상 메서드란, 함수 선언만 되어있고 구현부가 없는 아래와 같은 메서드를  추상 메서드라고 합니다. 
</pre>

#### 추상클래스는 왜 존재하는가?
<pre>
추상 클래스의 일부 다형성 보장 
추상 클래스는 "다형성"을 보장하기 위해 나타난 개념인데요. 
"자식 클래스에서 반드시 재정의가 되어야 된다"는 점에서 다형성이 보장됩니다. 
부모 클래스에서 추상 메서드를 선언하면,  자식 클래스는 부모의 추상적 메서드를 상속받아 메서드를 구현해 그 기능들을 구현 가능한데요. 이 때 부모가 가진 추상 메소드들을 자식 클래스에서 반드시 재정의(오버라이딩)해야 합니다.  
즉 부모가 자식에게 명령을 내렸을 때 자식 클래스가 반드시 동작되도록 재정의한다는 점에서 다형성이 보장됩니다. 
</pre>

#### 다형성이란 무엇인가?
<pre>
다형성이란 프로그램 언어 각 요소들(상수, 변수, 식, 객체, 메소드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다.
정리하면 다형성이란 하나의 타입에 여러 객체를 대입할 수 있는 성질로 이해하면 될 것이다.
</pre>

#### 추상클래스 
<pre>
오브젝트 라는 책에서는 올바른 추상클래스를 템플릿 메서드 패턴으로 사용하는 것을 추상 클래스라고 해요
단순히 A1 A2 가 변수가 겹쳐서 이 변수 중복제거를 위해 A 라는 추상 클래스를 사용하는 것이 아니라 
인터페이스 처럼 다형성을 위해 사용하지만 추가적으로 변수 사용 또는 일부 메서드를 구현해 놓아야 할 경우 인터페이스 대신 추상 클래스를 사용하는거라고 생각합니다
</pre>




4. Java 의 equals 와 == 의 차이에 대해 설명해주세요.<br>
https://go-coding.tistory.com/m/35<br>
<pre>
 == 연산자는 int,boolean과 같은 primitive type에 대해서는 값을 비교한다. reference type에 대해서는 주소값을 비교한다. 
 사실 primitive type도 Constant Pool에 있는 특정 상수를 참조하는 것이기 때문에 결국 주소값을 비교하는 것으로 볼 수 있다.

</pre>


#### 자바 코드를 열어본적이있나요? equlas를 Object랑 String을 열어본적이있습니다.
<pre>
String 클래스의 equals는
먼저 equals()변수로 들어온 객체가 자기 자신과 주소값이 같으면if (this == anObject)(이부분) true를 리턴한다.
주소 값이 다르다면 String 객체의 문자열을 Char 타입으로 하나씩 비교해 보면서 끝까지 같다면 true를 리턴 다르다면 false를 리턴한다.
String클래스에는 처음부터 equals()가 문자열을 비교하게 재정의 되어 만들어져있기 때문에 문자열 비교가 가능했던 것이다.

참고로 text1은 new 연산자가 아닌 = "" 로 만들었기 때문에 힙 영역안에 String Constant Pool에 (주소,값) 형태로 저장되어 진다. 그 이후 ""로 생성한 String객체는 먼저 String Constant Pool 안에 자신이 생성할 문자열과 같은 값이 존재하는지 찾아본다. 같은 값이 존재한다면 공간을 새로 만드는 것이 아니라 주소값을 미리 만들어진 String Constant Pool에 있는 값에 연결한다. 결국 같은 값을 가르키게 때문에 == 연산 , equals() 연산 둘다 true를 리턴하게 될 것이다.
가장 중요한 포인트는 ==는 주소값이 같은지 아닌지 비교하는 것이고, equals()연산도 내부적으로 주소값을 비교하지만 String클래스에서는 equals()를 재정의해 내용을 비교하게 되어있다.
</pre>

#### String new와 "" 생성차이
<https://jackjeong.tistory.com/m/13><br>
<pre>
String은 다른 일반 객체와 달리 Heap 영역 안에 String Constant Pool 영역에서도 관리해주는데 (constant poll은 static == method영역)
""로 생성하면 한번만 객체가 생성되지만, new로 생성하면 객체가 계속 생성된다고 한다

Java의 String은 Immutable Class (불변 클래스)이고, 
기본 타입(Primitive Type)이 아닌 참조 타입(Reference Type)이다.
따라서 String의 값은 Stack Memory 영역이 아닌 Heap Memory 영역에 저장이 된다.

그런데 String은 다른 객체들과 달리 조금 특별한 클래스이다.
String은 Heap Memory 영역에 String Pool 이라는 영역을 따로 두어 그곳에 저장한다 (Java 7이상)

s1, s2처럼 큰 따옴표로 String 객체를 생성하면, 
먼저 String pool에 같은 값이 있는지 확인하고 있으면 그 주소값을 리턴하고,
없다면 새로운 객체를 만들어 String pool에 할당한 뒤 그 주소값을 리턴한다

 

s3, s4처럼 new로 생성하면,
다른 객체들처럼 강제로 Heap 영역에 생성하고 그 주소값을 리턴한다.
그런데, 다른 객체들과 다른 점이 하나 있다.
만약 "jackCoding"이 String pool에 없었다면,
String pool 영역에 1개, heap 영역에 1개 총 2개의 객체를 생성한다.
위에는 이미 "jackCoding"이라는 값을 가진 객체가 String pool에 있기 때문에 heap 영역에만 생성되었다
즉 new로 생성은 만약 String constatnt pool에 값이 없으면 String constant pool하나 heap영역하나 이렇게 2개생성을 해버린다.
</pre>



7. final 키워드를 변수, 메소드, 클래스에 선언하는 것은 어떤 의미가 있습니까?
<pre>
변수에 선언하면 상수, 메서드에 생성하면 오버라이드 불가능 

변수에 final을 붙여보겠습니다. 변수에 final을 붙이면 이 변수는 수정할 수 없다는 의미를 가집니다. 수정될 수 없기 때문에 초기화 값은 필수적입니다. 
메서드에 final을 붙이면 override를 제한하게 됩니다.
final 키워드를 클래스에 붙이면 상속 불가능 클래스가 됩니다. 즉, 다른 클래스에서 상속하여 재정의를 할 수 없는 것입니다.
</pre>





