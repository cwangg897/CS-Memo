8. synchronized 를 메소드에 선언하는 것과, 특정 객체에 선언하는 것은 어떤 차이가 있습니까?
<pre>


</pre>


#### 가시성
<pre>
가시성 문제
여러 개의 스레드가 사용됨에 따라, CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 생기는 문제를 의미한다. 이를 해결하기 위해서는 가시성이 보장되어야 하는 변수를 CPU Cache Memory가 아니라 RAM에서 바로 읽도록 보장해야 한다.
이때 변수에 valatile 키워드를 붙임으로써 가시성을 보장할 수 있다.
</pre>

#### 동시성 프로그래밍의 문제
<pre>
동시성 프로그래밍에서는 CPU와 RAM의 중간에 위치하는 CPU Cache Memory와 병렬성이라는 특징때문에 다수의 스레드가 공유 자원에 접근할 때 두 가지 문제가 발생할 수 있다.
가시성 문제
원자성(동시접근) 문제
</pre>

### 가시성(데이터 불일치)
<pre>
volatile 키워드는 어디까지나 volatile 변수를 메인 메모리로부터 읽을 수 있게 해 주는 것이 전부이고,
다른 스레드에 의해 이 값이 언제든 바뀔 수 있다. 
즉, 가시성이란 공유 데이터를 읽는 경우의 동시성만 보장하는 것이라 생각하면 된다.
</pre>

### 원자성
<pre>
참고로 원자성 문제를 synchronized 또는 atomic을 통해 해결한다면 가시성의 문제도 해결된다. synchronized 블럭을 들어가기 전에 CPU Cache Memory와 Main Memory를 동기화 해주며, atomic의 경우에는 CAS 알고리즘에 의해 원자성 문제와 CPU Cache Memory에 잘못된 값을 참조하는 문제를 동시에 해결해주기 때문이다.
</pre>

#### Synchronized
<pre>
자바에서는 메모리가 크게는 static(method), heap, stack으로 나누어져있습니다
자바 멀티 스레드 환경에서는 스레드 끼리 static영역과 heap 영역을 공유하므로 공유자원에 대한 동기화 문제를 신경써야합니다.
원자성 문제를 해결하기 위한 방법 중 하나인 synchronized키워드에 대해 알아보자
</pre>


9. Reflection 을 유용하게 사용하는 사례를 말씀해 주세요.

10. JDK/JVM 은 대표적으로 OpenJDK 와 Oracle JDK 로 나뉘는데요, 업무에 어떤 JDK 를 사용하시겠습니까? 선택의 이유를 말씀해 주세요.

11. hashCode / equals 메소드의 역할에 대해 아시는 내용을 최대한 설명해주세요.

12. Java 의 Collections.unmodifiableList 같은 API 를 이용해 List 같은 collection 을 변경 불가능하게 만들 수 있습니다. 그렇다면 이 API 를 사용하면 immutability 를 달성할 수 있을까요?

13. 다음 싱글턴 코드의 어떤 점을 개선하실 수 있습니까? (개선이 필요 없을 수도 있음 / 왜?)
```java
class MySingleton {
  private static MySingleton instance;

  public static synchronized MySingleton getInstance() {
    if (instance == null) {
        instance = new MySingleton();
    }
    return instance;
  }
}
```
